searchState.loadedDescShard("imbl_sized_chunks", 0, "Sized Chunks\nA fixed capacity array sized to match some other type <code>T</code>.\nA fixed capacity smart array.\nA fixed capacity sparse array.\nThe maximum number of elements the <code>InlineArray</code> can hold.\nA draining iterator over the elements of an <code>InlineArray</code>.\nA fixed capacity array sized to match some other type <code>T</code>.\nA consuming iterator over the elements of an <code>InlineArray</code>.\nDiscard the contents of the array.\nConstruct an iterator that drains values from the front of …\nAppend the contents of the iterator to the back of the …\nAppend the contents of the iterator to the back of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInsert a new value at index <code>index</code>, shifting all the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTest if the array is empty.\nTest if the array is at capacity.\nGet the length of the array.\nConstruct a new empty array.\nPop an item from the back of the array.\nPush an item to the back of the array.\nRemove the value at index <code>index</code>, shifting all the …\nSplit an array into two, the original array containing …\nShortens the array, keeping the first <code>len</code> elements and …\nThe maximum number of elements this <code>Chunk</code> can contain.\nA fixed capacity smart array.\nA draining iterator over the elements of a <code>Chunk</code>.\nA consuming iterator over the elements of a <code>Chunk</code>.\nRemove all items from <code>other</code> and append them to the back of …\nGet a reference to the contents of the chunk as a mutable …\nGet a reference to the contents of the chunk as a slice.\nDiscard the contents of the chunk.\nConstruct a new chunk and populate it by taking <code>count</code> …\nConstruct an iterator that drains values from the front of …\nConstruct a new chunk and move every item from <code>other</code> into …\nRemove <code>count</code> items from the back of <code>other</code> and append them …\nRemove <code>count</code> items from the front of <code>other</code> and append them …\nDiscard all items up to but not including <code>index</code>.\nDiscard all items from <code>index</code> onward.\nAppend the contents of the iterator to the back of the …\nAppend the contents of the iterator to the back of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a new chunk and populate it by taking <code>count</code> …\nConstruct a new chunk and populate it by taking <code>count</code> …\nInsert a new value at index <code>index</code>, shifting all the …\nInsert multiple values at index <code>index</code>, shifting all the …\nInsert a new value into the chunk in sorted order.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTest if the chunk is empty.\nTest if the chunk is at capacity.\nGet the length of the chunk.\nConstruct a new empty chunk.\nConstruct a new chunk with two items.\nPop an item off the back of the chunk.\nPop an item off the front of the chunk.\nPush an item to the back of the chunk.\nPush an item to the front of the chunk.\nRemove the value at index <code>index</code>, shifting all the …\nUpdate the value at index <code>index</code>, returning the old value.\nSplit a chunk into two, the original chunk containing …\nConstruct a new chunk with one item.\nThe maximum number of elements a <code>SparseChunk</code> can contain.\nA draining iterator over the elements of a <code>SparseChunk</code>.\nAn iterator over references to the elements of a …\nAn iterator over mutable references to the elements of a …\nA draining iterator over <code>Option</code>s of the elements of a …\nAn iterator over <code>Option</code>s of references to the elements of …\nAn iterator over <code>Option</code>s of mutable references to the …\nA fixed capacity sparse array.\nTurn the chunk into an iterator over the values contained …\nMake an iterator of pairs of indices and references to the …\nFind the first index which contains a value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the value at a given index.\nGet a mutable reference to the value at a given index.\nGet an unchecked reference to the value at a given index.\nGet an unchecked mutable reference to the value at a given …\nMake an iterator over the indices which contain values.\nInsert a new value at a given index.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTest if the chunk is empty.\nTest if the chunk is at capacity.\nMake an iterator of references to the values contained in …\nMake an iterator of mutable references to the values …\nGet the length of the chunk.\nConstruct a new empty chunk.\nMake a draining iterator of `Option’s of the values …\nMake an iterator of <code>Option</code>s of references to the values …\nMake an iterator of <code>Option</code>s of mutable references to the …\nConstruct a new chunk with two items.\nRemove the first value present in the array.\nRemove the value at a given index.\nConstruct a new chunk with one item.")