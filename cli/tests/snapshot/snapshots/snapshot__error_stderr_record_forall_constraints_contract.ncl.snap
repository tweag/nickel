---
source: tests/snapshot/main.rs
expression: err
---
error: contract broken by the caller: field not allowed in tail: `x`
  ┌─ [INPUTS_PATH]/errors/record_forall_constraints_contract.ncl:3:19
  │
3 │ let f | forall r. { ; r } -> { x: Number; r } = fun r => %record_insert% "x" r 1 in f { x = 0 }
  │                   -------                                                             --------- evaluated to this expression
  │                   │                                                                    
  │                   expected type of the argument provided by the caller
  │
  ┌─ <unknown> (generated by evaluation):1:1
  │
1 │ { ... }
  │ ------- evaluated to this value
  │
  = This error may happen in the following situation:
        1. A function `f` is bound by a contract: e.g. `Number -> Number`.
        2. `f` is called with an argument of the wrong type: e.g. `f false`.
  = Either change the contract accordingly, or call `f` with an argument of the right type.
  = Note: this is an illustrative example. The actual error may involve deeper nested functions calls.

note: 
  ┌─ [INPUTS_PATH]/errors/record_forall_constraints_contract.ncl:3:58
  │
3 │ let f | forall r. { ; r } -> { x: Number; r } = fun r => %record_insert% "x" r 1 in f { x = 0 }
  │                                                          ^^^^^^^^^^^^^^^^^^^^^^^ While calling to r

note: 
  ┌─ [INPUTS_PATH]/errors/record_forall_constraints_contract.ncl:3:85
  │
3 │ let f | forall r. { ; r } -> { x: Number; r } = fun r => %record_insert% "x" r 1 in f { x = 0 }
  │                                                                                     ----------- (1) calling f

note: 
  ┌─ [INPUTS_PATH]/errors/record_forall_constraints_contract.ncl:3:49
  │
3 │ let f | forall r. { ; r } -> { x: Number; r } = fun r => %record_insert% "x" r 1 in f { x = 0 }
  │                                                 -------------------------------- (2) calling <func>


