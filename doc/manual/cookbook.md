---
slug: cookbook
---

# Cookbook

For now, this is an unorganized, temporary document not to forget some pieces of
the user manual that are not yet put in the right place.

## Library (record of functions)

You should use **type annotations** for records of functions. Currently Nickel
doesn't have a specific notion of a library or a module. You can just put
functions inside a record. In accordance with the previous section, you should
also use a type annotation on your record to make the type of the functions
accessible to the outside. Otherwise, the record is typed as `Dyn` and will
obliterate the types, making your library basically unusable inside typed code.

### Example

DON'T

```nickel
{
  foo :  Number -> Number = fun x => x + 1,
  bar : Number -> Number = foo,
}
```

BUT DO

```nickel
{
  foo = fun x => x + 1,
  bar = foo,
} : {
  foo : Number -> Number,
  bar : Number -> Number,
}
```

Alternatively, you can repeat your types both at the function level and at the
record level. It makes code more navigable and `query`-friendly, but at the
expense of repetition and duplicated contract checks. It is also currently
required for polymorphic functions because of [the following
bug](https://github.com/tweag/nickel/issues/360).

## Unit/documentation tests

With the `nickel test` command, nickel supports using documentation examples as
tests. This command extracts markdown blocks in documentation metadata, and runs
them as nickel snippets. For example, if the file "main.ncl" contains

````nickel
{
  foo
    | Number
    | doc m%"
    This is my field named foo.

    ## Examples

    ```nickel
      1 + "2"
    ```
    "%
}
````

then running `nickel test main.ncl` will fail with the error message

```console
testing foo/0...FAILED
test foo/0 failed
error: dynamic type error
  ┌─ [..]/test.ncl:1:7
  │
1 │   1 + "2"
  │       ^^^ this expression has type String, but Number was expected
  │
  = (+) expects its 2nd argument to be a Number

1 failures
error: tests failed
```

Only code blocks with the "nickel" tag are tested.

### Testing for expected output

In order to check that a test evaluates to a given value, terminate its
code block with a comment like `# => <expected output>`. This is equivalent
to applying a `std.contract.Equal <expected output>` contract, but might
look better in the rendered documentation. For example, running
`nickel test` on

````nickel
{
  foo
    | Number
    | doc m%"
    This is my field named foo.

    ## Examples

    ```nickel
      1 + 1
      # => 3
    ```
    "%
}
````

will output

```console
testing foo/0...FAILED
test foo/0 failed
error: contract broken by a value
  ┌─ <unknown> (generated by evaluation):1:1
  │
1 │ std.contract.Equal 3
  │ -------------------- expected type
  │
  ┌─ /home/jneeman/tweag/nickel/test.ncl:1:3
  │
1 │   1 + 1
  │   ^^^^^ applied to this expression
  │
  ┌─ <unknown> (generated by evaluation):1:1
  │
1 │ 2
  │ - evaluated to this value

1 failures
error: tests failed
```

### Checking for errors

Sometimes you want a test case to ensure that errors are raised when
appropriate. You can check for this by terminating a code block with
a comment like `# => error: <expected error text>`, and the test runner
will check that the example raises and error, and that the error message
contains "\<expected error text\>" as a substring. To test for an error
without checking the error message, terminate a code block with `# => error`.

For example,

````nickel
{
  foo
    | Number
    | doc m%"
    This is my field named foo.

    ## Examples

    ```nickel
      1 + "2"
      # => error: has type String, but Number was expected
    ```
    "%
}
````

### Ignoring tests

To ignore a test while still keeping the code block tagged as nickel
source, add the "ignore" label, like

````text
```nickel ignore
1 | String
```
````

### Multiline tests

If you have many short examples, you might prefer not to wrap each
one in a separate code block. In this case, you can use the "multiline"
label to create multiple blank-line-separated tests in a single code block.
For example,

````nickel
{
  foo
    | Number
    | doc m%"
    This is my field named foo.

    ## Examples

    ```nickel multiline
      1 + "2"
      # => error: has type String, but Number was expected

      1 + 1
      # => 2

      1 + 2
      # => 3
    ```
    "%
}
````

### The test expression's environment

Each test expression will be evaluated in the same environment as the field it's
documenting: the name of the field will be in scope, along with the names of all
the sibling fields.

For example, the following tests will succeed:

````nickel
{
  bar
    | Number
    = 2,

  foo
    | Number
    | doc m%"
    This is my field named foo.

    ## Examples

    ```nickel
      foo
      # => 1
    ```

    ```nickel
      foo + bar
      # => 3
    ```
    "%
    = 1,
}
````
