//! A builder interface for producing Nickel records.
//!
//! Using this module, you can define Nickel records using a builder style. For example
//! ```rust
//! # use nickel_lang_core::term::{MergePriority, Term, RichTerm};
//! # use nickel_lang_builder::record::Record;
//! let b = Record::new()
//!     .field("foo")
//!     .priority(MergePriority::Bottom)
//!     .doc("foo?")
//!     .not_exported()
//!     .value(Term::Str("foo".into()));
//! let t : RichTerm = b
//!     .field("bar")
//!     .value(Term::Num(42.into()))
//!     .into();
//! ```
//!
//! ## Warning
//! `RichTerm`s generated by this module are not suitable for evaluation by Nickel. They should only ever be pretty printed.
use codespan::Files;
use nickel_lang_core::{
    identifier::Ident,
    parser::utils::{build_record, FieldPathElem},
    position::{RawSpan, TermPos},
    term::{
        record::{self, FieldMetadata, RecordAttrs, RecordData},
        LabeledType, MergePriority, RichTerm, Term,
    },
    types::{self, EnumRows, RecordRows, TypeF},
};

type StaticPath = Vec<Ident>;

// This is horrible. But Nickel assumes in various places that `TermPos` are
// set, for example when building record fields piece by piece. This will work as
// long as the resulting Nickel term is only pretty printed. Expect evaluation to
// fail horribly on any error.
fn fake_termpos() -> TermPos {
    TermPos::Original(RawSpan {
        src_id: Files::default().add("<fake>", ""),
        start: 0.into(),
        end: 0.into(),
    })
}

/// Typestate style tag for `Field`s that are not yet completely specified
pub struct Incomplete();

/// Typestate style tag for `Field`s that have been finalized
pub struct Complete(Option<RichTerm>);

/// A Nickel record field being constructed
#[derive(Debug)]
pub struct Field<RB> {
    record: RB,
    path: StaticPath,
    metadata: FieldMetadata,
}

pub struct Types(pub TypeF<Box<Types>, RecordRows, EnumRows>);

impl From<TypeF<Box<Types>, RecordRows, EnumRows>> for Types {
    fn from(value: TypeF<Box<Types>, RecordRows, EnumRows>) -> Self {
        Types(value)
    }
}

impl From<Types> for types::Types {
    fn from(t: Types) -> Self {
        Self {
            types: t
                .0
                .map(|ty| Box::new(Self::from(*ty)), |rrow| rrow, |erow| erow),
            pos: TermPos::None,
        }
    }
}

impl<A> Field<A> {
    /// Attach documentation metadata to the field
    pub fn doc(self, doc: impl AsRef<str>) -> Self {
        self.some_doc(Some(doc))
    }

    /// Attach documentation metadata to the field, optionally
    pub fn some_doc(mut self, some_doc: Option<impl AsRef<str>>) -> Self {
        self.metadata.doc = some_doc.map(|d| d.as_ref().to_owned());
        self
    }

    /// Mark the field as optional
    pub fn optional(self) -> Self {
        self.set_optional(true)
    }

    /// Mark the field as optional or not, depending on `opt`
    pub fn set_optional(mut self, opt: bool) -> Self {
        self.metadata.opt = opt;
        self
    }

    /// Mark the field as `not_exported`
    pub fn not_exported(self) -> Self {
        self.set_not_exported(true)
    }

    /// Mark the field as `not_exported` or not, depending on the argument
    pub fn set_not_exported(mut self, not_exported: bool) -> Self {
        self.metadata.not_exported = not_exported;
        self
    }

    /// Attach a contract to the field
    pub fn contract(mut self, contract: impl Into<Types>) -> Self {
        self.metadata.annotation.contracts.push(LabeledType {
            types: types::Types::from(contract.into()),
            label: Default::default(),
        });
        self
    }

    /// Attach possibly multiple contracts to the field
    pub fn contracts<I>(mut self, contracts: I) -> Self
    where
        I: IntoIterator<Item = Types>,
    {
        self.metadata
            .annotation
            .contracts
            .extend(contracts.into_iter().map(|c| LabeledType {
                types: c.into(),
                label: Default::default(),
            }));
        self
    }

    /// Attach a type annotation to the field
    pub fn types(mut self, t: impl Into<Types>) -> Self {
        self.metadata.annotation.types = Some(LabeledType {
            types: types::Types::from(t.into()),
            label: Default::default(),
        });
        self
    }

    /// Set the field's merge priority
    pub fn priority(mut self, priority: MergePriority) -> Self {
        self.metadata.priority = priority;
        self
    }

    /// Set the field's metadata all at once
    pub fn metadata(mut self, metadata: FieldMetadata) -> Self {
        self.metadata = metadata;
        self
    }
}

impl Field<Incomplete> {
    /// Construct an incomplete [`Field`] at a given path
    pub fn path<I, It>(path: It) -> Self
    where
        I: AsRef<str>,
        It: IntoIterator<Item = I>,
    {
        Field {
            record: Incomplete(),
            path: path.into_iter().map(|e| e.as_ref().into()).collect(),
            metadata: Default::default(),
        }
    }

    /// Construct an incomplete [`Field`] with a given name
    pub fn name(name: impl AsRef<str>) -> Self {
        Self::path([name])
    }

    /// Finalize the [`Field`] without setting a value
    pub fn no_value(self) -> Field<Complete> {
        Field {
            record: Complete(None),
            path: self.path,
            metadata: self.metadata,
        }
    }

    /// Finalize the [`Field`] by setting its value
    pub fn value(self, value: impl Into<RichTerm>) -> Field<Complete> {
        Field {
            record: Complete(Some(value.into())),
            path: self.path,
            metadata: self.metadata,
        }
    }
}

impl Field<Complete> {
    /// Attach a finalized [`Field`] to a [`Record`]
    pub fn with_record(self, r: Record) -> Record {
        let v = self.record;
        let f = Field {
            record: r,
            path: self.path,
            metadata: self.metadata,
        };
        match v {
            Complete(Some(v)) => f.value(v),
            Complete(None) => f.no_value(),
        }
    }
}

impl Field<Record> {
    /// Finalize the [`Field`] without setting a value
    pub fn no_value(mut self) -> Record {
        self.record.fields.push((
            self.path,
            record::Field {
                metadata: self.metadata,
                ..Default::default()
            },
        ));
        self.record
    }

    /// Finalize the [`Field`] by setting its a value
    pub fn value(mut self, value: impl Into<RichTerm>) -> Record {
        self.record.fields.push((
            self.path,
            record::Field {
                value: Some(value.into()),
                metadata: self.metadata,
                ..Default::default()
            },
        ));
        self.record
    }
}

/// A Nickel record being constructed
#[derive(Debug)]
pub struct Record {
    fields: Vec<(StaticPath, record::Field)>,
    attrs: RecordAttrs,
}

fn elaborate_field_path(
    path: StaticPath,
    content: record::Field,
) -> (FieldPathElem, record::Field) {
    let mut it = path.into_iter();
    let fst = it.next().unwrap();

    let content = it.rev().fold(content, |acc, id| {
        record::Field::from(RichTerm::from(Term::Record(RecordData {
            fields: [(id, acc)].into(),
            ..Default::default()
        })))
    });

    (FieldPathElem::Ident(fst), content)
}

impl Record {
    /// Make a new, empty record builder
    pub fn new() -> Self {
        Record {
            fields: vec![],
            attrs: Default::default(),
        }
    }

    /// Start constructing a field with the given name
    pub fn field(self, name: impl AsRef<str>) -> Field<Record> {
        Field {
            record: self,
            path: vec![Ident::new_with_pos(name, fake_termpos())],
            metadata: Default::default(),
        }
    }

    /// Attach possibly multiple fields to this record
    pub fn fields<I, It>(mut self, fields: It) -> Self
    where
        I: Into<Field<Complete>>,
        It: IntoIterator<Item = I>,
    {
        for f in fields {
            self = f.into().with_record(self)
        }
        self
    }

    /// Start constructing a field at the given path
    pub fn path<It, I>(self, path: It) -> Field<Record>
    where
        I: AsRef<str>,
        It: IntoIterator<Item = I>,
    {
        Field {
            record: self,
            path: path
                .into_iter()
                .map(|e| Ident::new_with_pos(e, fake_termpos()))
                .collect(),
            metadata: Default::default(),
        }
    }

    /// Set all record attributes at once
    pub fn attrs(mut self, attrs: RecordAttrs) -> Self {
        self.attrs = attrs;
        self
    }

    // Clippy correctly observes that `open` is the only field in `RecordAttrs`.
    // Nevertheless, we want to do the record update. That way we can be
    // somewhat futureproof in case new fields are added to `RecordAttrs` in
    // Nickel.
    #[allow(clippy::needless_update)]
    /// Mark this record as "open" when used as a contract
    pub fn open(mut self) -> Self {
        self.attrs = RecordAttrs {
            open: true,
            ..self.attrs
        };
        self
    }

    // See `open` for comments on the clippy directive
    #[allow(clippy::needless_update)]
    /// Mark this record as "open" when used as a contract, depending on the value of `open`
    pub fn set_open(mut self, open: bool) -> Self {
        self.attrs = RecordAttrs { open, ..self.attrs };
        self
    }

    /// Finalize the record and turn it into a [`nickel_lang_core::term::RichTerm`]
    pub fn build(self) -> RichTerm {
        let elaborated = self
            .fields
            .into_iter()
            .map(|(path, rt)| elaborate_field_path(path, rt))
            .collect::<Vec<_>>();
        build_record(elaborated, self.attrs).into()
    }
}

impl Default for Record {
    fn default() -> Self {
        Self::new()
    }
}

impl<I, It> From<It> for Record
where
    I: Into<Field<Complete>>,
    It: IntoIterator<Item = I>,
{
    fn from(f: It) -> Self {
        Record::new().fields(f)
    }
}

impl From<Record> for RichTerm {
    fn from(val: Record) -> Self {
        val.build()
    }
}

#[cfg(test)]
mod tests {
    use nickel_lang_core::{
        parser::utils::{build_record, FieldPathElem},
        term::{RichTerm, TypeAnnotation},
        types::{TypeF, Types},
    };

    use pretty_assertions::assert_eq;

    use super::*;

    fn term(t: Term) -> record::Field {
        record::Field::from(RichTerm::from(t))
    }

    #[test]
    fn trivial() {
        let t: RichTerm = Record::new()
            .field("foo")
            .value(Term::Str("bar".into()))
            .into();
        assert_eq!(
            t,
            build_record(
                vec![(
                    FieldPathElem::Ident(Ident::new_with_pos("foo", fake_termpos())),
                    term(Term::Str("bar".to_owned().into()))
                )],
                Default::default()
            )
            .into()
        );
    }

    #[test]
    fn from_iter() {
        let t: RichTerm = Record::from([
            Field::name("foo").value(Term::Null),
            Field::name("bar").value(Term::Null),
        ])
        .into();
        assert_eq!(
            t,
            build_record(
                vec![
                    (
                        FieldPathElem::Ident(Ident::new_with_pos("foo", fake_termpos())),
                        term(Term::Null)
                    ),
                    (
                        FieldPathElem::Ident(Ident::new_with_pos("bar", fake_termpos())),
                        term(Term::Null)
                    ),
                ],
                Default::default()
            )
            .into()
        );
    }

    #[test]
    fn some_doc() {
        let t: RichTerm = Record::from([
            Field::name("foo").some_doc(Some("foo")).no_value(),
            Field::name("bar").some_doc(None as Option<&str>).no_value(),
            Field::name("baz").doc("baz").no_value(),
        ])
        .into();
        assert_eq!(
            t,
            build_record(
                vec![
                    (
                        FieldPathElem::Ident(Ident::new_with_pos("foo", fake_termpos())),
                        record::Field {
                            metadata: FieldMetadata {
                                doc: Some("foo".into()),
                                ..Default::default()
                            },
                            ..Default::default()
                        }
                    ),
                    (
                        FieldPathElem::Ident(Ident::new_with_pos("bar", fake_termpos())),
                        Default::default()
                    ),
                    (
                        FieldPathElem::Ident(Ident::new_with_pos("baz", fake_termpos())),
                        record::Field {
                            metadata: FieldMetadata {
                                doc: Some("baz".into()),
                                ..Default::default()
                            },
                            ..Default::default()
                        }
                    )
                ],
                Default::default()
            )
            .into()
        );
    }

    #[test]
    fn fields() {
        let t: RichTerm = Record::new()
            .fields([
                Field::name("foo").value(Term::Str("foo".into())),
                Field::name("bar").value(Term::Str("bar".into())),
            ])
            .into();
        assert_eq!(
            t,
            build_record(
                vec![
                    (
                        FieldPathElem::Ident(Ident::new_with_pos("foo", fake_termpos())),
                        term(Term::Str("foo".into()))
                    ),
                    (
                        FieldPathElem::Ident(Ident::new_with_pos("bar", fake_termpos())),
                        term(Term::Str("bar".into()))
                    ),
                ],
                Default::default()
            )
            .into()
        );
    }

    #[test]
    fn fields_metadata() {
        let t: RichTerm = Record::new()
            .fields([
                Field::name("foo").optional().no_value(),
                Field::name("bar").optional().no_value(),
            ])
            .into();
        assert_eq!(
            t,
            build_record(
                vec![
                    (
                        FieldPathElem::Ident(Ident::new_with_pos("foo", fake_termpos())),
                        record::Field {
                            metadata: FieldMetadata {
                                opt: true,
                                ..Default::default()
                            },
                            ..Default::default()
                        }
                    ),
                    (
                        FieldPathElem::Ident(Ident::new_with_pos("bar", fake_termpos())),
                        record::Field {
                            metadata: FieldMetadata {
                                opt: true,
                                ..Default::default()
                            },
                            ..Default::default()
                        }
                    ),
                ],
                Default::default()
            )
            .into()
        );
    }

    #[test]
    fn overriding() {
        let t: RichTerm = Record::new()
            .path(vec!["terraform", "required_providers"])
            .value(Record::from([
                Field::name("foo").value(Term::Null),
                Field::name("bar").value(Term::Null),
            ]))
            .path(vec!["terraform", "required_providers", "foo"])
            .value(Term::Str("hello world!".into()))
            .into();
        assert_eq!(
            t,
            build_record(
                vec![
                    elaborate_field_path(
                        vec!["terraform".into(), "required_providers".into()],
                        term(build_record(
                            vec![
                                (
                                    FieldPathElem::Ident(Ident::new_with_pos(
                                        "foo",
                                        fake_termpos()
                                    )),
                                    term(Term::Null)
                                ),
                                (
                                    FieldPathElem::Ident(Ident::new_with_pos(
                                        "bar",
                                        fake_termpos()
                                    )),
                                    term(Term::Null)
                                )
                            ],
                            Default::default()
                        ))
                    ),
                    elaborate_field_path(
                        vec![
                            Ident::new_with_pos("terraform", fake_termpos()),
                            Ident::new_with_pos("required_providers", fake_termpos()),
                            Ident::new_with_pos("foo", fake_termpos())
                        ],
                        term(Term::Str("hello world!".into()))
                    )
                ],
                Default::default()
            )
            .into()
        );
    }

    #[test]
    fn open_record() {
        let t: RichTerm = Record::new().open().into();
        assert_eq!(t, build_record(vec![], RecordAttrs { open: true }).into());
    }

    #[test]
    fn prio_metadata() {
        let t: RichTerm = Record::new()
            .field("foo")
            .priority(MergePriority::Top)
            .no_value()
            .into();
        assert_eq!(
            t,
            build_record(
                vec![(
                    FieldPathElem::Ident("foo".into()),
                    record::Field {
                        metadata: FieldMetadata {
                            priority: MergePriority::Top,
                            ..Default::default()
                        },
                        ..Default::default()
                    }
                )],
                Default::default()
            )
            .into()
        );
    }

    #[test]
    fn contract() {
        let t: RichTerm = Record::new()
            .field("foo")
            .contract(TypeF::String)
            .no_value()
            .into();
        assert_eq!(
            t,
            build_record(
                vec![(
                    FieldPathElem::Ident(Ident::new_with_pos("foo", fake_termpos())),
                    record::Field {
                        metadata: FieldMetadata {
                            annotation: TypeAnnotation {
                                contracts: vec![LabeledType {
                                    types: Types {
                                        types: TypeF::String,
                                        pos: TermPos::None
                                    },
                                    label: Default::default()
                                }],
                                ..Default::default()
                            },
                            ..Default::default()
                        },
                        ..Default::default()
                    }
                )],
                Default::default()
            )
            .into()
        );
    }

    #[test]
    fn exercise_metadata() {
        let t: RichTerm = Record::new()
            .field("foo")
            .priority(MergePriority::Bottom)
            .doc("foo?")
            .contract(TypeF::String)
            .types(TypeF::Number)
            .optional()
            .not_exported()
            .no_value()
            .into();
        assert_eq!(
            t,
            build_record(
                vec![(
                    FieldPathElem::Ident(Ident::new_with_pos("foo", fake_termpos())),
                    record::Field {
                        metadata: FieldMetadata {
                            doc: Some("foo?".into()),
                            opt: true,
                            priority: MergePriority::Bottom,
                            not_exported: true,
                            annotation: TypeAnnotation {
                                types: Some(LabeledType {
                                    types: Types {
                                        types: TypeF::Number,
                                        pos: TermPos::None
                                    },
                                    label: Default::default()
                                }),
                                contracts: vec![LabeledType {
                                    types: Types {
                                        types: TypeF::String,
                                        pos: TermPos::None
                                    },
                                    label: Default::default()
                                }],
                            },
                        },
                        ..Default::default()
                    }
                )],
                Default::default()
            )
            .into()
        );
    }
}
