use identifier::Ident;
use std::str::FromStr;
use types::{Types, AbsType};
use label::{Label, TyPath};
use term::{BinaryOp, RichTerm, Term, UnaryOp};

grammar;

pub Term: RichTerm = SpTerm<RichTerm>;

SpTerm<Rule>: RichTerm =
    <l: @L> <t: Rule> <r: @R> => match t {
        RichTerm {term: t, pos: _} => RichTerm {term: t, pos: Some((l, r))}
    };

RichTerm: RichTerm = {
    "fun" <p:Pattern> "=>" <t: SpTerm<Term>> =>
        RichTerm::new(Term::Fun(p, t)),
    "let" <id:Ident> "=" <t1:SpTerm<Term>> "in" <t2:SpTerm<Term>> =>
        RichTerm::new(Term::Let(id, t1, t2)),
    "if" <b:SpTerm<Term>> "then" <t:SpTerm<Term>> "else" <e:SpTerm<Term>> =>
        RichTerm::app(RichTerm::app(RichTerm::new(Term::Op1(UnaryOp::Ite(), b)), t), e),
    SpTerm<Operation>    
};

Operation: RichTerm = {
    <t1: SpTerm< Applicative>> <op: BOp> <t2: SpTerm<Operation>> => RichTerm::new(Term::Op2(op, t1, t2)),
    <op: UOp> <t: SpTerm<Operation>> => RichTerm::new(Term::Op1(op, t)),
    SpTerm< Applicative>,
};

Applicative: RichTerm = {
    <t1:SpTerm< Applicative>> <t2: SpTerm<Atom>> => RichTerm::new(Term::App(t1, t2)),
    SpTerm<Atom>,
};

Atom: RichTerm = {
    "(" <SpTerm<Term>> ")",
    <l:@L> "Promise(" <ty: Types> "," <t: SpTerm<Term>> ")" <r:@R> =>
        RichTerm::new(Term::Promise(ty, Label{tag: "A promise".to_string(), l: l, r: r, polarity: true, path: TyPath::Nil()}, t)),
    <l:@L> "Assume(" <ty: Types> "," <t: SpTerm<Term>> ")" <r:@R> =>
        RichTerm::new(Term::Assume(ty, Label{tag: "An assume".to_string(), l: l, r: r, polarity: true, path: TyPath::Nil()}, t)), 
    Num => RichTerm::new(Term::Num(<>)),
    Bool => RichTerm::new(Term::Bool(<>)),
    Ident => RichTerm::new(Term::Var(<>)),
};

Pattern: Ident = {
    Ident,
};

Ident: Ident = r"[[:alpha:]_][[:word:]-]*" => Ident(<>.to_string());

Num: f64 = r"[-+]?[0-9]*\.?[0-9]+" => f64::from_str(<>).unwrap();

Bool: bool = {
    "true" => true,
    "false" => false,
};

UOp: UnaryOp = {
    "isZero" => UnaryOp::IsZero(),
    "isNum" => UnaryOp::IsNum(),
    "isBool" => UnaryOp::IsBool(),
    "isFun" => UnaryOp::IsFun(),
    "blame" => UnaryOp::Blame(),
    "chngPol" => UnaryOp::ChangePolarity(),
    "goDom" => UnaryOp::GoDom(),
    "goCodom" => UnaryOp::GoCodom(),
    "tag[" <DbgStr> "]" => UnaryOp::Tag(<>),
};

BOp: BinaryOp = {
    "+" => BinaryOp::Plus(),
};

Types: Types = {
    <s: subType> "->" <t:Types> => Types(AbsType::Arrow(Box::new(s), Box::new(t))),
    <subType>,
};

subType : Types = {
    "Dyn" => Types(AbsType::Dyn()),
    "Num" => Types(AbsType::Num()),
    "Bool" => Types(AbsType::Bool()),
    "#" <SpTerm<RichTerm>> => Types(AbsType::Flat(<>)),
    "(" <Types> ")" => <>,
};

DbgStr: String = r"[[:alpha:]_][[:word:]-]*" => <>.to_string();
