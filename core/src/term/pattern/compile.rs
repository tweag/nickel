//! Compilation of pattern matching down to pattern-less Nickel code.
//!
//! # Algorithm
//!
//! Compiling patterns amounts to generate a decision tree - concretely, a term composed mostly of
//! nested if-then-else - which either succeeds to match a value and returns the bindings of
//! pattern variables, or fails and returns `null`.
//!
//! Compilation of pattern matching is a well-studied problem in the literature, where efficient
//! algorithms try to avoid the duplication of checks by "grouping" them in a smart way. A standard
//! resource on this topic is the paper [_Compiling Pattern Matching to Good Decision
//! Trees_](https://dl.acm.org/doi/10.1145/1411304.1411311) by Luc Maranget.
//!
//! The current version of pattern compilation in Nickel is naive: it simply compiles each pattern
//! to a checking expression and tries them all until one works. We don't expect pattern matching
//! to be relevant for performance anytime soon (allegedly, there are much more impacting aspects
//! to handle before that). We might revisit this in the future if pattern matching turns out to be
//! a bottleneck.
//!
//! Most building blocks are generated programmatically rather than written out as e.g. members of
//! the [crate::stdlib::internals] module. While clunkier, this makes it easier to change
//! the compilation strategy in the future and is more efficient in the current setting (combining
//! building blocks from the standard library would require much more function applications, while
//! we can generate inlined versions on-the-fly here).
use indexmap::IndexMap;

use super::*;
use crate::{
    error::EvalErrorKind,
    eval::value::NickelValue,
    metrics::increment,
    mk_app,
    position::PosTable,
    term::{
        BinaryOp, MatchBranch, MatchData, NAryOp, RecordExtKind, RecordOpKind, Term, UnaryOp, make,
        record::FieldMetadata,
    },
};

/// Generate a standard `%record/insert%` primop as generated by the parser.
fn record_insert() -> BinaryOp {
    BinaryOp::RecordInsert {
        ext_kind: RecordExtKind::WithValue,
        metadata: Default::default(),
        pending_contracts: Default::default(),
        // We don't really care for optional fields here and we don't need to filter them out
        op_kind: RecordOpKind::ConsiderAllFields,
    }
}

/// Generate a Nickel expression which inserts a new binding in the working dictionary.
///
/// `%record/insert% "<id>" bindings_id value_id`
fn insert_binding(id: LocIdent, value_id: LocIdent, bindings_id: LocIdent) -> NickelValue {
    mk_app!(
        make::op2(
            record_insert(),
            NickelValue::string_posless(id.label()),
            Term::Var(bindings_id)
        ),
        Term::Var(value_id)
    )
}

/// Generate a Nickel expression which removes `field` from `rest`.
///
/// ```nickel
/// %record/remove% "<field>" <rest>
/// ```
fn remove_from_rest(rest: NickelValue, field: LocIdent) -> NickelValue {
    make::op2(
        BinaryOp::RecordRemove(RecordOpKind::ConsiderAllFields),
        NickelValue::string_posless(field.label()),
        rest,
    )
}

/// Generate a Nickel expression which checks if a field is defined in a record provided as a
/// variable, and if not, insert a default value. Return the result (either the original record
/// unchanged, or the original record with the default value). The resulting record is guaranteed
/// to have the `field` defined. The implementation uses merging to avoid dropping the contracts
/// and other metadata affected to `field`, if the field exists but has no definition.
///
/// More precisely, [with_default_value] generates the following code:
///
/// ```nickel
/// if !(%record/field_is_defined% "<field>" record_id) then
///   if %record/has_field% "<field>" record_id then
///     record_id & { "<field>" = default }
///   else
///     # Merging is potentially more costly, and we can just fallback to record insertion here.
///     %record/insert% "<field>" record_id default
/// else
///   record_id
/// ```
pub(crate) fn with_default_value(
    pos_table: &mut PosTable,
    record_id: LocIdent,
    field: LocIdent,
    default: NickelValue,
) -> NickelValue {
    let field_not_defined = make::op1(
        UnaryOp::BoolNot,
        make::op2(
            BinaryOp::RecordFieldIsDefined(RecordOpKind::ConsiderAllFields),
            NickelValue::string_posless(field.label()),
            Term::Var(record_id),
        ),
    );

    let has_field = make::op2(
        BinaryOp::RecordHasField(RecordOpKind::ConsiderAllFields),
        NickelValue::string_posless(field.label()),
        Term::Var(record_id),
    );

    let insert = mk_app!(
        make::op2(
            record_insert(),
            NickelValue::string_posless(field),
            make::var(record_id)
        ),
        default.clone()
    );

    let inner_let_if = make::if_then_else(
        has_field,
        update_with_singleton_merge(pos_table, record_id, field, Field::from(default)),
        insert,
    );

    make::if_then_else(field_not_defined, inner_let_if, Term::Var(record_id))
}

fn update_with_singleton_merge(
    pos_table: &mut PosTable,
    record_id: LocIdent,
    id: LocIdent,
    field: Field,
) -> NickelValue {
    update_with_merge(pos_table, record_id, IndexMap::from([(id, field)]))
}

/// Update a record field by merging it with a singleton record containing the new value.
///
/// ```nickel
/// record_id & { "<id>" = <field> }
/// ```
fn update_with_merge(
    pos_table: &mut PosTable,
    record_id: LocIdent,
    fields: IndexMap<LocIdent, Field>,
) -> NickelValue {
    use crate::{ast::MergeKind, label::MergeLabel};

    let annot_spans = fields.values().flat_map(|v| {
        v.metadata
            .annotation
            .iter()
            .filter_map(|labeled_ty| labeled_ty.label.span)
    });
    let value_spans = fields.values().filter_map(|f| {
        f.value
            .as_ref()
            .and_then(|v| pos_table.get(v.pos_idx()).into_opt())
    });
    let span = annot_spans
        .chain(value_spans)
        // We fuse all the definite spans together.
        // unwrap(): all span should come from the same file
        .reduce(|span1, span2| span1.fuse(span2).unwrap());

    let singleton = NickelValue::record_posless(RecordData {
        fields,
        ..Default::default()
    });
    // Right now, patterns are compiled on-the-fly during evaluation. We thus need to
    // perform the gen_pending_contract transformation manually, or the contracts will
    // just be ignored. One step suffices, as we create a singleton record that doesn't
    // contain other non-transformed records (the default value, if any, has been
    // transformed normally).
    //
    // unwrap(): typechecking ensures that there are no unbound variables at this point
    let singleton =
        crate::transform::gen_pending_contracts::transform_one(pos_table, singleton).unwrap();

    // Since we generate a non-recursive record and inject it in the evaluation, we must manually
    // enforce it's properly closurized.
    let singleton = NickelValue::term_posless(Term::Closurize(singleton));

    let merge_label = MergeLabel {
        span,
        kind: MergeKind::Standard,
    };

    make::op2(
        BinaryOp::Merge(merge_label),
        Term::Var(record_id),
        singleton,
    )
}

pub trait CompilePart {
    /// Compile part of a broader pattern to a Nickel expression with two free variables (which
    /// is equivalent to a function of two arguments):
    ///
    /// 1. The value being matched on (`value_id`)
    /// 2. A dictionary of the current assignment of pattern variables to sub-expressions of the
    ///    matched expression (`bindings_id`)
    ///
    /// The compiled expression must return either `null` if the pattern doesn't match, or a
    /// dictionary mapping pattern variables to the corresponding sub-expressions of the
    /// matched value if the pattern matched with success.
    ///
    /// Although the `value` and `bindings` could be passed as [crate::term::NickelValue] in all
    /// generality, forcing them to be variable makes it less likely that the compilation
    /// duplicates sub-expressions: because the value and the bindings must always be passed in
    /// a variable, they are free to share without risk of duplicating work.
    fn compile_part(
        &self,
        pos_table: &mut PosTable,
        value_id: LocIdent,
        match_cont: NickelValue,
        fail_cont: NickelValue,
    ) -> NickelValue;
}

impl CompilePart for Pattern {
    // Compilation of the top-level pattern wrapper (code between < and > is Rust code, think
    // a template of some sort):
    //
    // < if let Some(alias) = alias { >
    //   let bindings = %record/insert% <alias> bindings arg in
    // < } >
    // <pattern_data.compile()> arg bindings
    fn compile_part(
        &self,
        pos_table: &mut PosTable,
        value_id: LocIdent,
        match_cont: NickelValue,
        fail_cont: NickelValue,
    ) -> NickelValue {
        let match_cont = if let Some(alias) = self.alias {
            make::let_one_in(alias, Term::Var(value_id), match_cont)
        } else {
            match_cont
        };

        self.data
            .compile_part(pos_table, value_id, match_cont, fail_cont)
    }
}

impl CompilePart for PatternData {
    fn compile_part(
        &self,
        pos_table: &mut PosTable,
        value_id: LocIdent,
        match_cont: NickelValue,
        fail_cont: NickelValue,
    ) -> NickelValue {
        match self {
            PatternData::Wildcard => match_cont,
            PatternData::Any(id) => make::let_one_in(*id, Term::Var(value_id), match_cont),
            PatternData::Record(pat) => {
                pat.compile_part(pos_table, value_id, match_cont, fail_cont)
            }
            PatternData::Array(pat) => pat.compile_part(pos_table, value_id, match_cont, fail_cont),
            PatternData::Enum(pat) => pat.compile_part(pos_table, value_id, match_cont, fail_cont),
            PatternData::Constant(pat) => {
                pat.compile_part(pos_table, value_id, match_cont, fail_cont)
            }
            PatternData::Or(pat) => pat.compile_part(pos_table, value_id, match_cont, fail_cont),
        }
    }
}

impl CompilePart for ConstantPattern {
    fn compile_part(
        &self,
        pos_table: &mut PosTable,
        value_id: LocIdent,
        match_cont: NickelValue,
        fail_cont: NickelValue,
    ) -> NickelValue {
        self.data
            .compile_part(pos_table, value_id, match_cont, fail_cont)
    }
}

impl CompilePart for ConstantPatternData {
    fn compile_part(
        &self,
        _: &mut PosTable,
        value_id: LocIdent,
        match_cont: NickelValue,
        fail_cont: NickelValue,
    ) -> NickelValue {
        let compile_constant = |nickel_type: &str, value: NickelValue| {
            // if %typeof% value_id == '<nickel_type> && value_id == <value> then
            //   match_cont
            // else
            //   fail_cont

            // %typeof% value_id == '<nickel_type>
            let type_matches = make::op2(
                BinaryOp::Eq,
                make::op1(UnaryOp::Typeof, Term::Var(value_id)),
                NickelValue::enum_tag_posless(nickel_type),
            );

            // value_id == <value>
            let value_matches = make::op2(BinaryOp::Eq, Term::Var(value_id), value);

            // <type_matches> && <value_matches>
            let if_condition = mk_app!(make::op1(UnaryOp::BoolAnd, type_matches), value_matches);

            make::if_then_else(if_condition, match_cont, fail_cont)
        };

        match self {
            ConstantPatternData::Bool(b) => {
                compile_constant("Bool", NickelValue::bool_value_posless(*b))
            }
            ConstantPatternData::Number(n) => {
                compile_constant("Number", NickelValue::number_posless(n.clone()))
            }
            ConstantPatternData::String(s) => {
                compile_constant("String", NickelValue::string_posless(s))
            }
            ConstantPatternData::Null => compile_constant("Other", NickelValue::null()),
        }
    }
}

impl CompilePart for OrPattern {
    // Compilation of or patterns.
    //
    //  <fold pattern in patterns
    //   - cont is the accumulator
    //   - initial accumulator is `null`
    //  >
    //
    //  let prev_bindings = cont in
    //
    //  # if one of the previous patterns already matched, we just stop here and return the
    //  # resulting updated bindings. Otherwise, we try the current one
    //  if prev_bindings != null then
    //    prev_bindings
    //  else
    //    <pattern.compile(value_id, bindings_id)>
    //  <end fold>
    fn compile_part(
        &self,
        pos_table: &mut PosTable,
        value_id: LocIdent,
        match_cont: NickelValue,
        fail_cont: NickelValue,
    ) -> NickelValue {
        // FIXME: docs plz
        self.patterns.iter().rev().fold(fail_cont, |cont, pattern| {
            pattern.compile_part(pos_table, value_id, match_cont.clone(), cont)
        })
    }
}

impl CompilePart for RecordPattern {
    // Compilation of the top-level record pattern wrapper.
    //
    // To check that the value doesn't contain extra fields, or to capture the rest of the
    // record when using the `..rest` construct, we need to remove matched fields from the
    // original value at each stage and thread this working value in addition to the bindings.
    //
    // We don't have tuples, so we thread through the bindings-in-progress and
    // the rest-in-progress as an array of two elements: `[bindings, rest]`.
    // If a match fails, either the array itself or `bindings` is null.
    //
    // if %typeof% value_id == 'Record
    //   let final_bindings_and_rest_id = <fold block (see below)> in
    //   let
    //     final_bindings_id = %array/at% final_bindings_and_rest_id 0,
    //     final_rest_id = %array/at% final_bindings_and_rest_id 1,
    //   if (final_bindings_and_rest_id == null) || (final_bindings_id == null) then
    //     null
    //   else
    //     <if self.tail is empty>
    //       # if tail is empty, check that the value doesn't contain extra fields
    //       if final_rest_id != {} then
    //         null
    //       else
    //         final_bindings_id
    //     <else if self.tail is capture(rest)>
    //         (%record/insert% <rest>
    //           final_bindings_id
    //           final_rest_id
    //         )
    //     <else if self.tail is open>
    //       final_bindings_id
    //     <end if>
    // else
    //   null
    fn compile_part(
        &self,
        pos_table: &mut PosTable,
        value_id: LocIdent,
        match_cont: NickelValue,
        fail_cont: NickelValue,
    ) -> NickelValue {
        // <id> == null
        fn id_eq_null(id: LocIdent) -> NickelValue {
            make::op2(BinaryOp::Eq, Term::Var(id), NickelValue::null())
        }

        // (<id1> == null) || (<id2> == null)
        fn id1_or_id2_eq_null(id1: LocIdent, id2: LocIdent) -> NickelValue {
            mk_app!(make::op1(UnaryOp::BoolOr, id_eq_null(id1)), id_eq_null(id2))
        }

        // %array/at% <array_id> <idx>
        fn array_at(array_id: LocIdent, idx: usize) -> NickelValue {
            make::op2(
                BinaryOp::ArrayAt,
                NickelValue::term_posless(Term::Var(array_id)),
                NickelValue::number_posless(idx),
            )
        }

        // [<first>, <second>]
        //
        // (specialized for the case that <second> is a Var)
        fn array2(first: NickelValue, second: LocIdent) -> NickelValue {
            NickelValue::array_posless(
                [first, NickelValue::term_posless(Term::Var(second))]
                    .into_iter()
                    .collect(),
                vec![],
            )
        }

        fn and(a: NickelValue, b: NickelValue) -> NickelValue {
            if a.is_bool_true() {
                b
            } else if b.is_bool_true() {
                a
            } else {
                mk_app!(make::op1(UnaryOp::BoolAnd, a), b)
            }
        }

        // %typeof% value_id == 'Record
        let is_record: NickelValue = make::op2(
            BinaryOp::Eq,
            make::op1(UnaryOp::Typeof, Term::Var(value_id)),
            NickelValue::enum_tag_posless("Record"),
        );

        let has_fields =
            self.patterns
                .iter()
                .fold(NickelValue::bool_true(), |has_other_fields, field_pat| {
                    if field_pat.default.is_some() {
                        has_other_fields
                    } else {
                        let has_field = make::op2(
                            BinaryOp::RecordFieldIsDefined(RecordOpKind::ConsiderAllFields),
                            NickelValue::string_posless(field_pat.matched_id.label()),
                            Term::Var(value_id),
                        );

                        and(has_field, has_other_fields)
                    }
                });

        let has_right_length = if self.is_open() {
            NickelValue::bool_true()
        } else {
            make::op2(
                BinaryOp::Eq,
                make::op1(
                    UnaryOp::ArrayLength,
                    make::op1(
                        UnaryOp::RecordFields(RecordOpKind::ConsiderAllFields),
                        Term::Var(value_id),
                    ),
                ),
                NickelValue::number_posless(self.patterns.len()),
            )
        };

        let matches_shallow = and(is_record, and(has_fields, has_right_length));

        let match_cont = if let TailPattern::Capture(tail) = self.tail {
            let tail_value = self.patterns.iter().fold(
                NickelValue::term_posless(Term::Var(value_id)),
                |tail, field_pat| {
                    make::op2(
                        BinaryOp::RecordRemove(RecordOpKind::ConsiderAllFields),
                        NickelValue::string_posless(field_pat.matched_id.label()),
                        tail,
                    )
                },
            );
            make::let_one_in(tail, tail_value, match_cont)
        } else {
            match_cont
        };

        let fold_block = self
            .patterns
            .iter()
            .fold(match_cont, |match_cont, field_pat| {
                let field = field_pat.matched_id;

                let match_cont =
                    field_pat
                        .pattern
                        .compile_part(pos_table, field, match_cont, fail_cont.clone());

                // %static_access(field)% value_id
                let extracted_value = make::op1(UnaryOp::RecordAccess(field), Term::Var(value_id));

                // let local_value_id = <extracted_value> in <updated_bindings_let>
                let match_cont = make::let_one_in(field, extracted_value, match_cont);

                // <if !field.annotation.is_empty()>
                //   let value_id = <update_with_merge...> in <binding_cont_let>
                // <end if>
                if !field_pat.annotation.is_empty() {
                    make::let_one_in(
                        value_id,
                        update_with_singleton_merge(
                            pos_table,
                            value_id,
                            field,
                            Field::from(FieldMetadata {
                                annotation: field_pat.annotation.clone(),
                                ..Default::default()
                            }),
                        ),
                        match_cont,
                    )
                } else {
                    match_cont
                }
            });

        // The fold block:
        //
        // <fold (field, value) in fields
        //  - cont is the accumulator
        //  - initial accumulator is [bindings_id, value_id]
        // >
        //
        // # If there is a default value, we must set it before the %record/field_is_defined% check below,
        // # because the default acts like if the original matched value always have this field
        // # defined
        // <if field.default.is_some()>
        //   let value_id = <with_default_value value_id field default> in
        // <end if>
        //
        // if %record/field_is_defined% field value_id then
        //   # If the field is present, we apply the potential contracts coming from user-provided
        //   # annotations before anything else. We just offload the actual work to `&`
        //   <if !field_pat.annotation.is_empty() >
        //     let value_id = value_id & { "<field>" | <field_pat.annotation> } in
        //   <end if>
        //
        //   let cont_and_rest_id = cont in
        //   let
        //     local_bindings_id = %array/at% cont_and_rest_id 0,
        //     local_rest_id = %array/at% cont_and_rest_id 1,
        //   in
        //   if (cont_and_rest_id == null) || (local_bindings_id == null) then
        //     null
        //   else
        //     let local_value_id = %static_access(field)% local_rest_id in
        //     let next_rest_id = <remove_from_rest(field, local_rest_id)> in
        //     <field.compile_part(local_value_id, local_bindings_id)>
        // let fold_block_and_rest: NickelValue =
        //     self.patterns.iter().fold(init, |cont_and_rest, field_pat| {
        //         let field = field_pat.matched_id;
        //         let local_bindings_id = LocIdent::fresh();
        //         let local_value_id = LocIdent::fresh();
        //         let local_rest_id = LocIdent::fresh();
        //         let next_rest_id = LocIdent::fresh();
        //         let cont_and_rest_id = LocIdent::fresh();

        //         let rest = NickelValue::term_posless(Term::Var(local_rest_id));

        //         // let next_rest_id = <remove_from_rest(field, cont_rest_id)> in
        //         // [<field.compile_part(local_value_id, local_bindings_id)>, next_rest_id]
        //         let updated_bindings_let = make::let_one_in(
        //             next_rest_id,
        //             remove_from_rest(rest.clone(), field),
        //             array2(
        //                 field_pat.pattern.compile_part(
        //                     pos_table,
        //                     local_value_id,
        //                     local_bindings_id,
        //                 ),
        //                 next_rest_id,
        //             ),
        //         );

        //         // %static_access(field)% init_rest_id
        //         let extracted_value = make::op1(UnaryOp::RecordAccess(field), rest);

        //         // let local_value_id = <extracted_value> in <updated_bindings_let>
        //         let inner_else_block =
        //             make::let_one_in(local_value_id, extracted_value, updated_bindings_let);

        //         // The innermost if:
        //         //
        //         // if (cont_and_rest_id == null) || (local_bindings_id == null) then
        //         //   null
        //         // else
        //         //  <inner_else_block>
        //         let inner_if = make::if_then_else(
        //             id1_or_id2_eq_null(cont_and_rest_id, local_bindings_id),
        //             NickelValue::null(),
        //             inner_else_block,
        //         );

        //         // let cont_and_rest_id = cont_and_rest in
        //         // let
        //         //   local_bindings_id = %array/at% cont_and_rest_id 0,
        //         //   local_rest_id = %array/at% cont_and_rest_id 1,
        //         // in <value_let>
        //         let binding_cont_let = make::let_one_in(
        //             cont_and_rest_id,
        //             cont_and_rest,
        //             make::let_in(
        //                 false,
        //                 [
        //                     (local_bindings_id, array_at(cont_and_rest_id, 0)),
        //                     (local_rest_id, array_at(cont_and_rest_id, 1)),
        //                 ],
        //                 inner_if,
        //             ),
        //         );

        //         // <if !field.annotation.is_empty()>
        //         //   let value_id = <update_with_merge...> in <binding_cont_let>
        //         // <end if>
        //         let optional_merge = if !field_pat.annotation.is_empty() {
        //             make::let_one_in(
        //                 value_id,
        //                 update_with_merge(
        //                     pos_table,
        //                     value_id,
        //                     field,
        //                     Field::from(FieldMetadata {
        //                         annotation: field_pat.annotation.clone(),
        //                         ..Default::default()
        //                     }),
        //                 ),
        //                 binding_cont_let,
        //             )
        //         } else {
        //             binding_cont_let
        //         };

        //         // %record/field_is_defined% field value_id
        //         let has_field = make::op2(
        //             BinaryOp::RecordFieldIsDefined(RecordOpKind::ConsiderAllFields),
        //             NickelValue::string_posless(field.label()),
        //             Term::Var(value_id),
        //         );

        //         // if <has_field> then <optional_merge> else null
        //         let enclosing_if =
        //             make::if_then_else(has_field, optional_merge, NickelValue::null());

        //         // <if field_pat.default.is_some()>
        //         //   let value_id = <with_default_value value_id field default> in
        //         // <end if>
        //         if let Some(default) = field_pat.default.as_ref() {
        //             make::let_one_in(
        //                 value_id,
        //                 with_default_value(pos_table, value_id, field, default.clone()),
        //                 enclosing_if,
        //             )
        //         } else {
        //             enclosing_if
        //         }
        //     });

        let inner_if = make::if_then_else(matches_shallow, fold_block, fail_cont);

        self.patterns.iter().fold(inner_if, |cont, field_pat| {
            if let Some(default) = field_pat.default.as_ref() {
                make::let_one_in(
                    value_id,
                    with_default_value(pos_table, value_id, field_pat.matched_id, default.clone()),
                    cont,
                )
            } else {
                cont
            }
        })
    }
}

impl CompilePart for ArrayPattern {
    // Compilation of an array pattern.
    //
    // let value_len = %array/length% value_id in
    //
    // <if self.is_open()>
    // if %typeof% value_id == 'Array && value_len >= <self.patterns.len()>
    // <else>
    // if %typeof% value_id == 'Array && value_len == <self.patterns.len()>
    // <end if>
    //
    //   let final_bindings_id =
    //     <fold (idx, elem_pat) in 0..self.patterns.len()
    //      - cont is the accumulator
    //      - initial accumulator is `bindings_id`
    //      >
    //
    //       let local_bindings_id = cont in
    //       if local_bindings_id == null then
    //         null
    //       else
    //         let local_value_id = %array/at% <idx> value_id in
    //         <elem_pat.compile_part(local_value_id, local_bindings_id)>
    //
    //     <end fold>
    //   in
    //
    //   if final_bindings_id == null then
    //     null
    //   else
    //     <if self.tail is capture(rest)>
    //       %record/insert%
    //         <rest>
    //         final_bindings_id
    //         (%array/slice% <self.patterns.len()> value_len value_id)
    //     <else>
    //       final_bindings_id
    //     <end if>
    // else
    //   null
    fn compile_part(
        &self,
        pos_table: &mut PosTable,
        value_id: LocIdent,
        match_cont: NickelValue,
        fail_cont: NickelValue,
    ) -> NickelValue {
        let value_len_id = LocIdent::fresh();
        let pats_len = NickelValue::number_posless(self.patterns.len());

        let match_cont = if let TailPattern::Capture(rest) = self.tail {
            make::let_one_in(
                rest,
                make::opn(
                    NAryOp::ArraySlice,
                    vec![
                        pats_len.clone(),
                        Term::Var(value_len_id).into(),
                        Term::Var(value_id).into(),
                    ],
                ),
                match_cont,
            )
        } else {
            match_cont
        };

        // <fold (idx) in 0..self.patterns.len()
        //  - cont is the accumulator
        //  - initial accumulator is `bindings_id`
        //  >
        //
        //   let local_bindings_id = cont in
        //   if local_bindings_id == null then
        //     null
        //   else
        //     let local_value_id = %array/at% <idx> value_id in
        //     <self.patterns[idx].compile_part(local_value_id, local_bindings_id)>
        //
        // <end fold>
        let fold_block: NickelValue =
            self.patterns
                .iter()
                .enumerate()
                .fold(match_cont, |match_cont, (idx, elem_pat)| {
                    let local_value_id = LocIdent::fresh();

                    // %array/at% idx value_id
                    let extracted_value = make::op2(
                        BinaryOp::ArrayAt,
                        Term::Var(value_id),
                        NickelValue::number_posless(idx),
                    );

                    make::let_one_in(
                        local_value_id,
                        extracted_value,
                        elem_pat.compile_part(
                            pos_table,
                            local_value_id,
                            match_cont,
                            fail_cont.clone(),
                        ),
                    )
                });

        // %typeof% value_id == 'Array
        let is_array: NickelValue = make::op2(
            BinaryOp::Eq,
            make::op1(UnaryOp::Typeof, Term::Var(value_id)),
            NickelValue::enum_tag_posless("Array"),
        );

        let comp_op = if self.is_open() {
            BinaryOp::GreaterOrEq
        } else {
            BinaryOp::Eq
        };

        // <is_array> && value_len <comp_op> <self.patterns.len()>
        let outer_check = mk_app!(
            make::op1(UnaryOp::BoolAnd, is_array),
            make::op2(comp_op, Term::Var(value_len_id), pats_len)
        );

        // let final_bindings_id = LocIdent::fresh();

        // // the else block which depends on the tail of the record pattern
        // let tail_block = match self.tail {
        //     // final_bindings_id
        //     TailPattern::Empty | TailPattern::Open => make::var(final_bindings_id),
        //     // %record/insert%
        //     //    <rest>
        //     //    final_bindings_id
        //     //    (%array/slice% <self.patterns.len()> value_len value_id)
        //     TailPattern::Capture(rest) => mk_app!(
        //         make::op2(
        //             record_insert(),
        //             NickelValue::string_posless(rest.label()),
        //             Term::Var(final_bindings_id),
        //         ),
        //         make::opn(
        //             NAryOp::ArraySlice,
        //             vec![
        //                 pats_len,
        //                 Term::Var(value_len_id).into(),
        //                 Term::Var(value_id).into()
        //             ]
        //         )
        //     ),
        // };

        // // the last `final_bindings_id != null` guard:
        // //
        // // if final_bindings_id == null then
        // //   null
        // // else
        // //   <tail_block>
        // let guard_tail_block = make::if_then_else(
        //     make::op2(
        //         BinaryOp::Eq,
        //         Term::Var(final_bindings_id),
        //         NickelValue::null(),
        //     ),
        //     NickelValue::null(),
        //     tail_block,
        // );

        // // The let enclosing the fold block and the let binding `final_bindings_id`:
        // // let final_bindings_id = <fold_block> in <tail_block>
        // let outer_let = make::let_one_in(final_bindings_id, fold_block, guard_tail_block);

        // if <outer_check> then <outer_let> else null
        let outer_if = make::if_then_else(outer_check, fold_block, fail_cont);

        // finally, we need to bind `value_len_id` to the length of the array
        make::let_one_in(
            value_len_id,
            make::op1(UnaryOp::ArrayLength, Term::Var(value_id)),
            outer_if,
        )
    }
}

impl CompilePart for EnumPattern {
    fn compile_part(
        &self,
        pos_table: &mut PosTable,
        value_id: LocIdent,
        match_cont: NickelValue,
        fail_cont: NickelValue,
    ) -> NickelValue {
        // %enum/get_tag% value_id == '<self.tag>
        let tag_matches = make::op2(
            BinaryOp::Eq,
            make::op1(UnaryOp::EnumGetTag, Term::Var(value_id)),
            NickelValue::enum_tag_posless(self.tag),
        );

        if let Some(pat) = &self.pattern {
            // if %enum/is_variant% value_id && %enum/get_tag% value_id == '<self.tag> then
            //   let value_id = %enum/get_arg% value_id in
            //   <pattern.compile(value_id, bindings_id)>
            // else
            //   null

            // %enum/is_variant% value_id && <tag_matches>
            let if_condition = mk_app!(
                make::op1(
                    UnaryOp::BoolAnd,
                    make::op1(UnaryOp::EnumIsVariant, Term::Var(value_id)),
                ),
                tag_matches
            );

            let next_value_id = LocIdent::fresh();

            make::if_then_else(
                if_condition,
                make::let_one_in(
                    next_value_id,
                    make::op1(UnaryOp::EnumGetArg, Term::Var(value_id)),
                    pat.compile_part(pos_table, next_value_id, match_cont, fail_cont.clone()),
                ),
                fail_cont,
            )
        } else {
            // if %typeof% value_id == 'Enum && !(%enum/is_variant% value_id) && <tag_matches> then
            //   bindings_id
            // else
            //   null

            // %typeof% value_id == 'Enum
            let is_enum = make::op2(
                BinaryOp::Eq,
                make::op1(UnaryOp::Typeof, Term::Var(value_id)),
                NickelValue::enum_tag_posless("Enum"),
            );

            // !(%enum/is_variant% value_id)
            let is_enum_tag = make::op1(
                UnaryOp::BoolNot,
                make::op1(UnaryOp::EnumIsVariant, Term::Var(value_id)),
            );

            // <is_enum> && <is_enum_tag> && <tag_matches>
            let if_condition = mk_app!(
                make::op1(UnaryOp::BoolAnd, is_enum,),
                mk_app!(make::op1(UnaryOp::BoolAnd, is_enum_tag,), tag_matches)
            );

            make::if_then_else(if_condition, match_cont, fail_cont)
        }
    }
}

pub trait Compile {
    /// Compile a match expression to a Nickel expression matching `value`.
    fn compile(self, pos_table: &mut PosTable, value: NickelValue, pos_idx: PosIdx) -> NickelValue;
}

impl Compile for MatchData {
    // Compilation of a full match expression (code between < and > is Rust code, think of it as a
    // kind of templating). Note that some special cases compile differently as optimizations.
    //
    // let value_id = value in
    //
    // <fold (pattern, body) in branches.rev()
    //  - cont is the accumulator
    //  - initial accumulator is the default branch (or error if not default branch)
    // >
    //    let init_bindings_id = {} in
    //    let bindings_id = <pattern.compile()> value_id init_bindings_id in
    //
    //    if bindings_id == null then
    //      cont
    //    else
    //      # this primop evaluates body with an environment extended with bindings_id
    //      %pattern_branch% body bindings_id
    fn compile(
        mut self,
        pos_table: &mut PosTable,
        value: NickelValue,
        pos_idx: PosIdx,
    ) -> NickelValue {
        increment!("pattern_compile");

        if self.branches.iter().all(|branch| {
            // While we could get something working even with a guard, it's a bit more work and
            // there's no current incentive to do so (a guard on a tags-only match is arguably less
            // common, as such patterns don't bind any variable). For the time being, we just
            // exclude guards from the tags-only optimization.
            matches!(
                branch.pattern.data,
                PatternData::Enum(EnumPattern { pattern: None, .. }) | PatternData::Wildcard
            ) && branch.guard.is_none()
        }) {
            let wildcard_pat = self.branches.iter().enumerate().find_map(
                |(
                    idx,
                    MatchBranch {
                        pattern,
                        guard,
                        body,
                    },
                )| {
                    if matches!((&pattern.data, guard), (PatternData::Wildcard, None)) {
                        Some((idx, body.clone()))
                    } else {
                        None
                    }
                },
            );

            // If we find a wildcard pattern, we record its index in order to discard all the
            // patterns coming after the wildcard, because they are unreachable.
            let default = if let Some((idx, body)) = wildcard_pat {
                self.branches.truncate(idx + 1);
                Some(body)
            } else {
                None
            };

            let tags_only = self
                .branches
                .into_iter()
                .filter_map(
                    |MatchBranch {
                         pattern,
                         guard: _,
                         body,
                     }| {
                        if let PatternData::Enum(EnumPattern { tag, .. }) = pattern.data {
                            Some((tag, body))
                        } else {
                            None
                        }
                    },
                )
                .collect();

            return TagsOnlyMatch {
                branches: tags_only,
                default,
            }
            .compile(pos_table, value, pos_idx);
        }

        let error_case = NickelValue::term(
            Term::RuntimeError(Box::new(EvalErrorKind::NonExhaustiveMatch {
                value: value.clone(),
                pos: pos_idx,
            })),
            pos_idx,
        );

        let value_id = LocIdent::fresh();

        // The fold block:
        //
        // <for branch in branches.rev()
        //  - cont is the accumulator
        //  - initial accumulator is the default branch (or error if not default branch)
        // >
        //    let init_bindings_id = {} in
        //    let bindings_id = <pattern.compile_part(value_id, init_bindings)> in
        //
        //    if bindings_id == null || !<guard> then
        //      cont
        //    else
        //      # this primop evaluates body with an environment extended with bindings_id
        //      %pattern_branch% body bindings_id
        let fold_block = self
            .branches
            .into_iter()
            .rev()
            .fold(error_case, |fail_cont, branch| {
                let match_cont = if let Some(guard) = branch.guard {
                    // the guard must be evaluated in the same environment as the body of the
                    // branch, as it might use bindings introduced by the pattern. Since `||` is
                    // lazy in Nickel, we know that `bindings_id` is not null if the guard
                    // condition is ever evaluated.
                    make::if_then_else(guard, branch.body, fail_cont.clone())
                } else {
                    branch.body
                };
                branch
                    .pattern
                    .compile_part(pos_table, value_id, match_cont, fail_cont)
            });

        // let value_id = value in <fold_block>
        let ret = make::let_one_in(value_id, value, fold_block);
        //eprintln!("{ret}");
        ret
    }
}

/// Simple wrapper used to implement specialization of match statements when all of the patterns
/// are enum tags. Instead of a sequence of conditionals (which has linear time complexity), we use
/// a special primops based on a hashmap, which has amortized constant time complexity.
struct TagsOnlyMatch {
    branches: Vec<(LocIdent, NickelValue)>,
    default: Option<NickelValue>,
}

impl Compile for TagsOnlyMatch {
    fn compile(self, _: &mut PosTable, value: NickelValue, pos_idx: PosIdx) -> NickelValue {
        increment!("pattern_comile(tags_only_match)");

        // We simply use the corresponding specialized primop in that case.
        let match_op = mk_app!(
            make::op1(
                UnaryOp::TagsOnlyMatch {
                    has_default: self.default.is_some()
                },
                value
            )
            .with_pos_idx(pos_idx),
            NickelValue::record_posless(RecordData::with_field_values(self.branches.into_iter()))
        );

        let match_op = if let Some(default) = self.default {
            mk_app!(match_op, default)
        } else {
            match_op
        };

        match_op.with_pos_idx(pos_idx)
    }
}
