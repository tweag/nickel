%use "init".
%use "row".

(* This file defines a bunch of tests across many features
 * of the Makam implementation of the Nickel language.
 *
 * They don't follow any particular organization and should be treated
 * as a minimal set of expected behaviour. Also as examples.
 *)

nickel : testsuite. 

testcase nickel :-
    raw_interpreter "(fun x => x + x) 3" (eint 6) tnum.

testcase nickel :-
    raw_interpreter "let (x = true) in Ifte(x, 34, false)" (eint 34) tdyn.

testcase nickel :-
    not (
        raw_interpreter "
        let ( id = fun t => t ) in
        Promise(Num,
            Ifte( ( Promise(Bool -> Bool, id) ) true, 3, Promise(Num, true)) 
        ) " _ _).

testcase nickel :-
    raw_interpreter "
        let ( id = fun t => t ) in

        Promise(Num,
        Ifte( ( Promise(Bool -> Bool, id) ) true, 3, Assume(Num, true))
        )
    " (eint 3) tnum.

testcase nickel :-
    not (
        raw_interpreter "
        let ( id = fun t => t ) in

        Promise(Num,
        Ifte( ( Promise(Bool -> Bool, id) ) false, 3, Assume(Num, true))
        )
        " _ _
    ).

testcase nickel :-
    raw_interpreter "
    let ( id = fun t => t ) in

    Promise(Num,
    Ifte( ( Promise(Bool -> Bool, id) ) false, 3, Assume(Num, 5))
    )
    " (eint 5) tnum.

testcase nickel :-
    not (
        interpreter "
        let (id = fun x => x) in
        Ifte(true, Promise(Num, id 3), Promise(Bool, id true))
        " _ _
    ).

testcase nickel :-
    raw_interpreter "
        let (id = fun x => x) in
        Ifte(true, Promise(Num, id 3), Assume(Bool, id true))
        " (eint 3) tdyn.

testcase nickel :-
    raw_interpreter "
    let (id = fun x => x) in
    Ifte(false, Promise(Num, id 3), Assume(Bool, id true))
    " (ebool true) tdyn.

testcase nickel :-
    raw_interpreter "
    let (id = fun x => x) in
    Ifte(false, Promise(Num, id 3), Assume(Bool, id true))
    " (ebool true) tdyn.

testcase nickel :-
    raw_interpreter "
    let (id = fun x => x) in
    Ifte(true, Assume(Bool, id true), Promise(Num, id 3))
    "
    (ebool true)
    tdyn.

testcase nickel :-
    raw_interpreter "
    let (id = fun x => x) in
    Ifte(true, Promise( Num , id 3), Promise( Bool, Assume( Bool -> Bool , id ) true))
    " (eint 3) tdyn.

testcase nickel :-
    not (
        raw_interpreter "
        let (void = fun l => fun t => blame l) in
        Assume(#void, 3)
        " _ _
    ).

testcase nickel :-
    not (
        raw_interpreter "
        let (alwaysTrue = fun l => fun t => Ifte(t, t, blame l)) in
        Assume(#alwaysTrue, false)
        " _ _
    ).

testcase nickel :-
    raw_interpreter "
    let (alwaysTrue = fun l => fun t => Ifte(t, t, blame l)) in
    Assume(#alwaysTrue, true)
    " (ebool true) (fromExpr (named "alwaysTrue")).

testcase nickel :-
    raw_interpreter "
    let (void = fun l => fun t => blame l) in
    Promise( #void -> #void, fun x => x)" V T,
    eq V (lam (bind "x" (fun x => x))),
    eq T (tarrow (fromExpr (named "void")) (fromExpr (named "void"))).

testcase nickel :-
    raw_interpreter "
    let (f = fun x => Ifte(x, f false, 3)) in
    f true
    " (eint 3) tnum.

testcase nickel :-
    raw_interpreter "
    let (f = (let (f = fun x => 3 - x) in f 1)) in f + f
    " (eint 4) tnum.

testcase nickel :-
    raw_interpreter "
    let (f = fun x => x + 1) in
    fun y => f y" 
    (lam (bind "y" (fun y => app (recThunk "f" (fun f => lam (bind "x" (fun x => ebinop x add (eint 1)))) V') y))) 
    (tarrow tnum tnum).


nickel_typing : testsuite.

testcase nickel_typing :-
    p_typecheck
    "true"
    tbool.

testcase nickel_typing :-
    p_typecheck
    "34"
    tnum.

testcase nickel_typing :-
    p_typecheck
    "34"
    tdyn.

testcase nickel_typing :-
    p_typecheck
    "\"hola\""
    tstr.

testcase nickel_typing :-
    p_typecheck
    "fun x => x"
    (tarrow A A).

testcase nickel_typing :-
    p_typecheck
    "fun x => x"
    (tarrow tdyn tdyn).

testcase nickel_typing :-
    p_typecheck
    "fun x => x"
    tdyn.

testcase nickel_typing :-
    p_typecheck
    "let (x = 34) in x + 2"
    tnum.

testcase nickel_typing :-
    p_typecheck
    "(fun x => x) 3"
    tnum.

testcase nickel_typing :-
    p_typecheck
    "Promise(Bool -> Bool, fun x => x) 3"
    tdyn.

testcase nickel_typing :-
    p_typecheck
    "Promise(Num -> Num, fun x => x) 3"
    tnum.

testcase nickel_typing :-
    not (p_typecheck
        "Promise(Num -> Bool, fun x => x) 3"
        _
    ).
(* forall *)

testcase nickel :-
    raw_interpreter "
    Promise(forall a . a -> a, fun x => x) "
    (lam (bind "x" (fun x => x)))
    (forall (bind "a" (fun a => tarrow a a))).

testcase nickel :-
    raw_interpreter "
    Promise(forall a . a -> a, fun x => x) 3 "
    (eint 3)
    (tdyn).

testcase nickel :-
    raw_interpreter "
    Assume(forall a . a -> a, fun x => x) 3 "
    (eint 3) tdyn.

testcase nickel :-
    not (raw_interpreter "
    Assume(forall a . a -> a, fun x => 2) 3 "
    _ _).

testcase nickel :-
    raw_interpreter 
    "(Assume(forall a . a -> (a -> a) ->  a, fun x => fun f => f x) 3) (fun y => 2 + y)"
    (eint 5)
    tdyn.

testcase nickel :-
    raw_interpreter
    "(Assume(forall a . a -> (a -> a) ->  a, fun x => fun f => f (f x)) 3) (fun y => 2 + y)"
    (eint 7)
    tdyn.

testcase nickel :-
    not (raw_interpreter
        "(Assume(forall a . a -> (a -> a) ->  a, fun x => fun f => f 2) 34) (fun y => 25 + y)"
        _ _
    ).

testcase nickel :-
    raw_interpreter
    "(Assume(forall a . a -> (a -> Num) ->  Num, fun x => fun f => f x) 3) (fun y => Ifte(isNum y, y, 0))"
    (eint 3)
    tdyn.

testcase nickel :-
    raw_interpreter
    "(Assume(forall a . a -> (a -> Num) ->  Num, fun x => fun f => f x) true) (fun y => Ifte(isNum y, y, 0))"
    (eint 0)
    tdyn.

testcase nickel :-
    raw_interpreter
    "(Assume(forall a . forall b . (a -> b) -> a -> b, fun f => f) (fun x => 34)) true"
    (eint 34)
    tdyn.

testcase nickel :-
    raw_interpreter
    "(Assume(Num -> (forall a. a -> a) -> Num, fun n => fun f => f n) 34) (fun x => x)"
    (eint 34)
    tnum.

testcase nickel :-
    raw_interpreter
        "let (f = Promise(forall a . a -> a, fun x => x)) in
        Promise((Num -> Num) -> Num, fun f => f 2) f"
        (eint 2) tnum.

testcase nickel :-
    not (raw_interpreter
        "let (f = Promise(forall a . a -> a, fun x => x)) in
        Promise(Num, Promise((Bool -> Num) -> Num, fun f => f true) f)"
        _ _ ).


testcase nickel :-
    raw_interpreter
        "let (f = Promise(forall a . a -> a, fun x => x)) in
        (Promise((Bool -> Num) -> Num, fun f => f true) f)"
        (ebool true) tdyn.

testcase nickel :-
    not (raw_interpreter
        "(Assume(Num -> (forall a. a -> a) -> Num, fun n => fun f => f n) 34) (fun x => 2)"
        _ _
    ).

(* Records *)

testcase nickel :-
    isocast 
    "{ hello : 3 ; chau : \"4\" ; $(Ifte(true, \"hello\", \"chau\")) : 5 ; $(Ifte(true, \"hello\", \"chau\")) : 4 }" 
    (E: expr),
    typecheck E (open_rec tnum [ ("hello", tnum) , ("chau", tstr)]).

testcase nickel :-
    isocast 
    "Promise({ _:Bool, hello: Num}, 3)" 
    (E: expr), 
    not (typecheck E _).

testcase nickel :-
    raw_interpreter "{$(\"bla\"): 5 }"
    (rec_val [ (tuple "bla" (eint 5)) ] (fun s => eunop blame (label false _ _ _)))
    (open_rec tnum []).

testcase nickel :-
    raw_interpreter 
    "{$(Ifte(true, \"hello\", \"chau\")) : false; $(\"bla\"): true; blop : true }.blop"
    (ebool true)
    tbool.

testcase nickel :-
    raw_interpreter 
    "{$(Ifte(true, \"hello\", \"chau\")) : false; $(\"bla\"): true; blop : true }.hello"
    (ebool false)
    tbool.

testcase nickel :-
    raw_interpreter 
    "{$(Ifte(true, \"hello\", \"chau\")) : false; $(\"bla\"): 3; blop : true }.hello"
    (ebool false)
    tdyn.

(* TODO: Still not checking that there are no extra fields *)
testcase nickel :-
    raw_interpreter
    "let (f = Assume({hello: Bool} -> Bool, fun x => (x).hello)) in
    f {hello: false }"
    (ebool false)
    tdyn.

testcase nickel :-
    not (
        raw_interpreter
        "let (f = Assume({hello: Bool} -> Bool, fun x => (x).hello)) in
        f {$\"hello\": true; $\"hola\": 42 ; chau : 3}"
        _ _
    ).

testcase nickel :-
    not (
        raw_interpreter
        "let (f = Assume({hello: Bool} -> Bool, fun x => (x).hello)) in
        f {hola: false ; chau : 3}"
        _ _
    ).

testcase nickel :-
    raw_interpreter
    "let (f = Promise({hello: Bool} -> Bool, fun x => (x).hello)) in
    f {hello: false ; chau : 3}"
    (ebool false)
    tdyn.

testcase nickel :-
    p_typecheck
    "Promise({hello: Bool} -> Bool, fun x => (x).hello)"
    (tarrow (clos_rec [("hello", tbool)]) tbool).

testcase nickel :-
    not(
        raw_interpreter
        "Assume( { _ : Bool , } , {blop : 3; blip : false}).blop"
        _ _
    ).

testcase nickel :-
    raw_interpreter
    "Assume({_: Bool ,}, {blop : 3; blip : false}).blip"
    (ebool false)
    tbool.

testcase nickel :-
    not (raw_interpreter
    "{blop: 3; blop: false}"
    _ _).

(* Rows *)

testcase nickel :-
    row.empty A, row.add 2 A, row.add 3 A,
    row.member A 2, row.member A 3, not(row.member A 1).

testcase nickel :-
    row.empty A, row.add 2 A, row.add 3 A, row.add 2 A,
    row.toList A [2, 3].

testcase nickel :-
    row.fromList [1, 2, 3, 1] R,
    row.member R 1, row.member R 2, row.member R 3,
    row.remove 1 R A, not(row.member A 1).

testcase nickel :-
    row.empty A, row.add 2 A, row.remove 2 A R,
    not (row.add 2 R).

testcase nickel :-
    row.empty A, row.add 2 A, row.close A,
    row.member A 2, not(row.add 3 A), row.add 2 A.

testcase nickel :-
    row.fromList [1,2 ,3] R, row.close R, row.fromList [1,2] RR, eqv RR R.

testcase nickel :-
    row.fromList [1,2 ,3] R, row.fromList [1,2] RR, row.close RR, not(eqv RR R).

(* Enums *)

testcase nickel :-
    isocast "[bla]ble" (enum_var "bla" "ble").


testcase nickel :-
    isocast "bla [ ble, blu] 2" (enum_def "bla" ["ble", "blu"] (eint 2)).


testcase nickel :-
    isocast 
        "case ([bla]ble) of bla { blu => 2 , ble => 0}"
        (enum_case
            (enum_var "bla" "ble")
            "bla"
            [("blu", eint 2), ("ble", eint 0)]
        ).

testcase nickel :-
    isocast
        "is[blop] 3"
        (eunop (isEnum "blop") (eint 3)).

testcase nickel :-
    isocast
        "Assume([bla], 2)"
        (assume (tenum "bla") _ (eint 2)).

testcase nickel :-
    raw_interpreter
        "bla [ble, blo, bli]
        Assume([bla], [bla]ble)"
        (enum_var "bla" "ble")
        _.

testcase nickel :-
    not(raw_interpreter
        "bla [blo, bli]
        Assume([bla], [bla]ble)"
        (enum_var "bla" "ble")
        _).

testcase nickel :-
    not(raw_interpreter
        "bla [ ]
        Assume([bla], [bla]ble)"
        (enum_var "bla" "ble")
        _).

testcase nickel :-
    raw_interpreter
    "bla [ble]
    (case ([bla]ble) of bla {bli => 0, ble => 1, blo => 34})"
    (eint 1)
    _.

testcase nickel :-
    not(raw_interpreter
    "bla []
    (case ([bla]ble) of bla {ble => 1, blo => 34})"
    (eint 1)
    _).

testcase nickel :-
    not(raw_interpreter
    "bla [ble]
    (case ([bla]ble) of bla {bli => 1, blo => 34})"
    (eint 1)
    _).
